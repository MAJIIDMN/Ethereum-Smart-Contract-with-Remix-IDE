// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SecureMilestonePayment {
    address payable public buyer;
    address payable public seller;

    uint256 public basePrice;
    uint256 createdAt;
    uint256 deliveryConfirmedAt;

    uint256 durationBeforeDelivery;
    uint256 durationAfterDelivery;

    bool public isVerified;
    bool public isRequesterApproved;
    bool public paid;
    bool public deliveryInitiated;
    bool public sellerLate;

    constructor(
        address payable _buyer,
        address payable _seller,
        uint256 _priceInETH,
        uint256 _durationBeforeMinutes,
        uint256 _durationAfterMinutes
    ) payable  {
        buyer = _buyer;
        seller = _seller;
        basePrice = _priceInETH * 1 ether;
        createdAt = block.timestamp;

        durationBeforeDelivery = _durationBeforeMinutes;
        durationAfterDelivery = _durationAfterMinutes;

        paid = false;
        deliveryInitiated = false;
        sellerLate = false;
    }

    modifier onlyBuyer() {
        require(msg.sender == buyer, "Only buyer can act");
        _;
    }

    modifier onlySeller() {
        require(msg.sender == seller, "Only seller can act");
        _;
    }

    function DeliveryVerified() external onlySeller {
        require(!deliveryInitiated, "Already confirmed");

        uint256 deadlineBeforeDelivery = createdAt + (durationBeforeDelivery * 1 minutes);
        if (block.timestamp > deadlineBeforeDelivery) {
            sellerLate = true;
        }

        isVerified = true;
        deliveryConfirmedAt = block.timestamp;
        deliveryInitiated = true;
    }

    function approveDelivery() external onlyBuyer {
        isRequesterApproved = true;
        require(!paid, "Already paid");
        require(deliveryInitiated, "Delivery not confirmed");
        require(isVerified && isRequesterApproved, "Conditions not met");

        uint256 amountToPay = getPaymentAmount();
        require(address(this).balance >= amountToPay, "Insufficient balance");

        paid = true;
        seller.transfer(amountToPay);
    }

    function getPaymentAmount() public view returns (uint256) {
        uint256 amount = basePrice;
        uint256 deliveryDeadline = deliveryConfirmedAt + (durationAfterDelivery * 1 minutes);
        if (block.timestamp > deliveryDeadline) {
            amount -= (basePrice * 5) / 100;
        }
        if (sellerLate) {
            amount -= (basePrice * 3) / 100;
        }

        return amount;
    }

    function payBackToBuyer() external onlyBuyer {
        require(paid, "transaction not completed");
        buyer.transfer(address(this).balance);
    }

    function getCountdownStatus()
        external
        view
        returns (
            bool beforeDeliveryActive,
            uint256 beforeDeliveryRemaining,
            bool afterDeliveryActive,
            uint256 afterDeliveryRemaining
        )
    {
        uint256 nowTime = block.timestamp;

        if (!deliveryInitiated) {
            uint256 endBefore = createdAt + (durationBeforeDelivery * 1 minutes);
            beforeDeliveryRemaining = nowTime >= endBefore ? 0 : endBefore - nowTime;
            beforeDeliveryActive = beforeDeliveryRemaining > 0;
        } else {
            beforeDeliveryActive = false;
            beforeDeliveryRemaining = 0;
        }

        if (deliveryInitiated) {
            uint256 endAfter = deliveryConfirmedAt + (durationAfterDelivery * 1 minutes);
            afterDeliveryRemaining = nowTime >= endAfter ? 0 : endAfter - nowTime;
            afterDeliveryActive = afterDeliveryRemaining > 0;
        } else {
            afterDeliveryActive = false;
            afterDeliveryRemaining = 0;
        }

        return (
            beforeDeliveryActive,
            beforeDeliveryRemaining,
            afterDeliveryActive,
            afterDeliveryRemaining
        );
    }

    receive() external payable {}
    fallback() external payable {}
}
